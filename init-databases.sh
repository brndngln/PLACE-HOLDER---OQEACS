#!/bin/bash
#
# init-databases.sh
#
# This script provisions the PostgreSQL databases and users required by
# the Omni platform. It reads credentials from the local `.env` file,
# connects to the omni-postgres service, and idempotently creates a
# database and dedicated user for each component. Running this script
# multiple times will not error or recreate existing entities.
#
# Usage:
#   bash scripts/init-databases.sh
#
# Requirements:
#   - The `psql` CLI must be installed and available in PATH.
#   - The `.env` file generated by generate-env.sh must exist in
#     the working directory.

set -euo pipefail

#############################
# COLOR LOGGING FUNCTIONS   #
#############################

# ANSI color codes for log output
GREEN="\033[0;32m"
YELLOW="\033[0;33m"
RED="\033[0;31m"
CYAN="\033[0;36m"
RESET="\033[0m"

log_info()    { printf "%b[INFO ]%b %s\n"   "$CYAN" "$RESET" "$1"; }
log_success() { printf "%b[SUCCESS]%b %s\n" "$GREEN" "$RESET" "$1"; }
log_warn()    { printf "%b[WARN ]%b %s\n"  "$YELLOW" "$RESET" "$1"; }
log_error()   { printf "%b[ERROR]%b %s\n" "$RED" "$RESET" "$1"; }

#############################
# ENVIRONMENT PREPARATION   #
#############################

ENV_FILE=".env"

if [[ ! -f "$ENV_FILE" ]]; then
  log_error "Missing $ENV_FILE. Please run generate-env.sh first."
  exit 1
fi

# Export variables from .env to the current environment
set -o allexport
source "$ENV_FILE"
set +o allexport

# PostgreSQL connection details
POSTGRES_HOST="${POSTGRES_HOST:-omni-postgres}"
POSTGRES_PORT="${POSTGRES_PORT:-5432}"
POSTGRES_USER="${POSTGRES_USER:-postgres}"
POSTGRES_PASSWORD="${POSTGRES_ROOT_PASSWORD:-}"

if [[ -z "$POSTGRES_PASSWORD" ]]; then
  log_error "POSTGRES_ROOT_PASSWORD is not defined in $ENV_FILE"
  exit 1
fi

# psql command wrapper
psql_exec() {
  PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d postgres -v ON_ERROR_STOP=1 "$@"
}

###################################
# DATABASE AND USER CONFIGURATION #
###################################

# Define the databases, users and corresponding password env vars. Each
# entry is formatted as "database_name:user_name:env_var_name". The
# password for each user will be pulled from the given environment
# variable. Ensure that generate-env.sh has produced these variables.
declare -a DB_DEFINITIONS=(
  "gitea_db:gitea:GITEA_DB_PASSWORD"
  "mattermost_db:mattermost:MATTERMOST_DB_PASSWORD"
  "n8n_db:n8n:N8N_DB_PASSWORD"
  "langfuse_db:langfuse:LANGFUSE_DB_PASSWORD"
  "plane_db:plane:PLANE_DB_PASSWORD"
  "authentik_db:authentik:AUTHENTIK_DB_PASSWORD"
  "wikijs_db:wikijs:WIKIJS_DB_PASSWORD"
  "superset_db:superset:SUPERSET_DB_PASSWORD"
  "calcom_db:calcom:CALCOM_DB_PASSWORD"
  "woodpecker_db:woodpecker:BUILD_FORGE_DB_PASSWORD"
  "coder_db:coder:CODE_FORGE_DB_PASSWORD"
  "sla_tracker_db:sla_tracker:SLA_TRACKER_DB_PASSWORD"
  "backup_orch_db:backup_orch:BACKUP_ORCH_DB_PASSWORD"
  "orchestrator_db:orchestrator:ORCHESTRATOR_DB_PASSWORD"
  "knowledge_db:knowledge:KNOWLEDGE_DB_PASSWORD"
)

###############################
# FUNCTION: create_user_db    #
###############################

# Idempotently create a PostgreSQL role and database. If the role
# already exists, its password is left unchanged; if the database
# exists, it is left intact. Otherwise both are created.
create_user_db() {
  local db_name="$1"
  local user_name="$2"
  local password="$3"

  # Validate password
  if [[ -z "$password" ]]; then
    log_error "Password for user $user_name is empty. Check your .env file."
    return 1
  fi

  # Create the role if it doesn't exist
  psql_exec -c "DO $$\nBEGIN\n    IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '${user_name}') THEN\n        CREATE ROLE ${user_name} LOGIN PASSWORD '${password}';\n    END IF;\nEND\n$$;" >/dev/null
  log_success "User '${user_name}' ensured."

  # Create the database if it doesn't exist and assign owner
  psql_exec -c "SELECT 'CREATE DATABASE ${db_name} OWNER ${user_name};'\n  WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '${db_name}')\n  \gexec" >/dev/null
  log_success "Database '${db_name}' ensured."
}

###############################
# MAIN EXECUTION LOOP         #
###############################

log_info "Provisioning PostgreSQL databases and users..."

for entry in "${DB_DEFINITIONS[@]}"; do
  IFS=":" read -r db_name user_name env_var <<< "$entry"
  # Fetch password from environment; if missing, warn
  # Using indirect expansion to get the value of the variable named by env_var
  password="${!env_var:-}"
  log_info "Ensuring DB '$db_name' and user '$user_name'..."
  create_user_db "$db_name" "$user_name" "$password"
done

log_info "All databases and users have been provisioned."
exit 0